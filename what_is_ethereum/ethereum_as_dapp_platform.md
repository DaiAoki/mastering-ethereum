## Ethereum

###分散アプリケーション開発の障壁

前節で、ブロックチェーン技術の革新性と、通貨（ビットコイン）だけに収まらない応用の可能性について述べてきました。

ブロックチェーン技術を用いた新たな応用サービスをローンチするためには、２つの選択肢があります。１つは新たなサービスのために新しいブロックチェーンを構築しそれを使ってサービスを行うこと。２つめは、ビットコインのような既存のブロックチェーンを利用しその上にサービスを構築するというものです。前節に挙げた応用例では、[Storj](http://storj.io/) や [Namecoin](https://namecoin.info/) は前者のタイプであり、[Proof of Existence](http://www.proofofexistence.com/) は後者のタイプになります。

新しいブロックチェーンを構築することは、非常に敷居の高い方法です。実装に相当の工数がかかります。さらに重要なのは、ブロックチェーンを用いた合意形成がサービスのローンチ当初から安定して動作するためには、相当数の参加者が事前に集まっている必要があるからです。これは需要の少ないニッチなサービスを展開する際には、非常に致命的な問題になります。

一方で、既存のビットコインのブロックチェーンを利用したサービス提供する場合は、あくまでビットコイン自体の設計上の制限に従う必要があり、非常に不自由なものとなってしまします。

###Ethereumとは
Ethereumは「分散アプリケーションプラットフォーム」です。分散アプリケーションが動作する基盤を用意することで、上述のような分散アプリケーションを開発する際の障壁を取り除くことを目的としています。

Ethereumは任意の処理が記述可能（チューリング完全）な、組み込みのプログラミング言語を備えます。分散アプリケーションの開発者は、この組み込みの言語を用いてプログラミングを行い開発を行います。分散アプリケーションのコードは、ブロックチェーンに組み込まれビットコインと同様にプルーフ・オブ・ワークの仕組みにより、改ざん不可能になります。このコードはEthereumネットワークに参加する各（採掘者の）ノード上で実行され、その結果の状態もブロックチェーンに組み込まれ、やはり改ざんが不可能になります。

Ethereumのプラットフォーム上で動作するよう開発された様々な分散アプリケーションは、Ethereumのブロックチェーンを共有して利用します。そのため利用者が少ないニッチな分散アプリケーションでも、分散システム上での「合意形成」が安定して動作することが可能です。

ここで、少しEthereumの仕組みの概略を見ていきましょう。（詳細は「Ethereumの内部」の章<!--[REF]-->で解説します。）

#### 内部通貨：ether
<!--[TODO]ここでいきなりスマート・コントラクトがでてくるため、事前に説明が必要-->
Ethereumでは、「ether」という独自の内部通貨が規定されています。ビットコインと同様、それ自体が価値を持つ通貨としての利用も可能ですが、より重要な事はetherがEthereum内で分散アプリケーションやスマート・コントラクトを実行するための「燃料」の役割を果たすという事です。Ethereumは上述のように、その上で動作する分散アプリケーションに対して、任意の処理を可能にしており、それぞれの分散アプリケーション間でその動作に必要な計算資源の量は異なってきます。そこで、Ethereumでは、分散アプリケーションを実行するためには、その処理の重さに応じた燃料が必要」とすることにより、Ethereum上で動作する分散アプリケーション間での計算資源の割り当ての平等性を確保しています。

etherは、単位名が通貨名と同じでetherですが、米国の通貨で、1 doller $$=$$ 100 cent と規定されているように、etherも利便性のためより少額のetherに対して下記のように単位名が決められています。

* 1 ether $$=$$ 10[^3] finney
* 1 ether $$=$$ 10[^6] szabo
* 1 ether $$=$$ 10[^18] wei


#### アカウント
<!-- 話しを簡略にするため、CA⇒CAのメッセージについては敢えて言及しない方針 -->
<!-- [TODO] アカウントはオブジェクト指向言語で言うクラスと似ている旨の記述を入れる -->
Ethereumには、「アカウント」と呼ばれるオブジェクトが既定されています。アカウントは16進数で表わされるアドレス（例えば、0x4c84913cc41f2aad9c24d82bfde598c91cdd33d3）[^1] により参照され、アカウント間で交わされるトランザクションによりアカウントの状態が変化していきます。

「アカウント」には２つのタイプが存在します。一つは「Externally Owned Account（EOA）」、もう一つは「Contract Account（CA）」です。アカウントは、主に次の４つのフィールドを持ち、そのフィールドの値が、つまりはそのアカウントの「状態」になります。

* nonce：そのアカウントが送信した累積トランザクション数
* ether balance：そのアカウントが所有するether量
* contract code：コントラクトのコード（EOAの場合は空）
* storage：そのアカウントが保持するデータ

EOAは、我々ユーザーにより生成されコントロールされるアカウントです。ユーザーの任意のタイミングでトランザクションを生成し、他EOAへのetherの送金、新しいCAの生成、CAのコードの実行を行います。

一方で、CAは、EOAからトランザクションを介して生成されます。CAは一種の自動エージェントであり、EOAが発信するトランザクションをトリガに、contract code フィールドに格納されたコード（コントラクト・コード）を実行します。

[^1] ここで先頭の「0x」は16進数を表わすプレフィックスです。

#### トランザクション
<!-- トランザクションを介して状態が変わること --＞
<!-- トランザクションは４つのフィールドを持っていること。 --＞
<!-- データフィールどの簡単な説明 -->
<!-- StartGasとGasPriceの簡単な説明 -->

Ethereumでは各アカウントの状態は「トランザクション」により遷移していきます [^1]。EOAがトランザクションを生成しそれをEthereumネットワーク上に送信します。採掘者は受信したトランザクションの正当性をチェックし問題なければ、そのトランザクションの情報とトランザクションの内容に基づいて変化した最新のアカウントの状態をブロックチェーンに埋め込みます。

トランザクションには主に以下の情報が含まれます。

* ether送金額
* 相手先アドレス
* 送信者署名
* 任意データ
* STARTGAS値
* GASPRICE値

最初の３つはビットコインのような暗号通貨のトランザクションと同じです。３つはそれぞれ、Ethereumの内部通貨であるetherの送金額と相手のアドレス、そしてトランザクションの送信者がether送金元アドレスの所有者であることを証明するデジタル署名です。

「任意データ」はトランザクションの相手先がCAである場合に、そのコントラクト・コードに引き渡すデータ格納します。

例えばIPアドレスとドメイン名の紐づけを管理するドメイン管理の分散アプリケーションを考えてみましょう。その場合にユーザーは、自分が登録したいIPアドレスとドメイン名の情報を分散アプリに対して引き渡し、分散アプリ側でその登録情報を管理することになります。このようなことを実現するために、ユーザーは分散アプリの処理（ここではドメインの登録情報の管理）を担うCAのアドレスを「相手先アドレス」に、かつ、自分の登録したい情報（ここではIPアドレスとドメイン名）を「任意データ」に格納したトランザクションを発生させます。一方そのトランザクションにより「任意データ」に格納されたデータを入力値としてコントラクト・コードが実行され、今回引き渡されたデータがすでに登録済みのものではない場合、CAの`storage`フィールドに格納された登録済みドメインリストに今回の登録情報が追加されることになります。

STARTGAS値と、GASPRICE値は、トランザクション手数料として支払うetherの量を規定する情報です。トランザクションに必要な手数料は、トランザクションが実行するコードの処理の数や、トランザクションのデータの大きさに応じて「gas」という単位で計算されます。トランザクションで支払う最大のgas量がSTARTGAS値であり、そしてその「gas」と内部通貨etherとの交換レートがGASPRICE値になります。

##### トランザクションの処理の流れ
ここでトランザクションによりどのようにアカウントの状態が変更されていくのかの処理の流れを見ていきます。大まかに以下のようになります。

1. EOAがトランザクションを生成し、Ethereumネットワーク上に送信する。
2. ネットワーク内の採掘者がトランザクションを受信する。
3. 採掘者は、署名の正当性など、受信したトランザクションのデータに問題がないかをチェック。問題がある場合はエラーとして以降の処理を行わない。
4. 採掘者はトランザクション内のSTARTGAS値とGASPRICE値を参照。「STARTGAS値 × GASPRICE値」の量のetherを、前払い手数料として、トランザクションを送信したアカウントの保有するetherから引く。もしetherの保有量が「STARTGAS値 × GASPRICE値」よりも少なければエラーとして以降の処理を行わない。
5. 残りGAS ＝ STARTGAS値 とする。
6. トランザクション・データの大きさ1バイト当たり5 gasを残りGASから引く。
5. トランザクション内で指定された相手に対して、指定された額のetherを送金。また「トランザクションの相手」がCAの場合は、CAの持つコードを実行。
6. 送金額のetherを送金者が保有していない、または、コードを実行中に残りGASがゼロになった場合には、手数料の支払情報のみを残し、元の状態にロールバックさせる。トランザクション実行前の状態から、トランザクション実行のための手数料分だけトランザクションの送信者の保有etherから引き、採掘者の保有額にそれを足した状態を終状態とする。
7. 送金、またはコードの実行が正常に終了し、GASが余っている場合は、その余ったGASをトランザクションの送信者に対して戻す。

[^1] 実際には、状態の遷移はトランザクションだけでなく、「メッセージ」によっても遷移が行われますがここでは説明を省きます。「トランザクション」はEOAにより生成/送信されるのに対して「メッセージ」はCAにより生成/送信されます。

#### ブロックチェーンと採掘
ビットコインのシステムで、ブロックチェーンはビットコイン・ネットワーク上で発生したすべてのトランザクションを記録した、誰でも参照可能な公開取引元帳の役割を果たしていました。

Ethereumのブロックチェーンも同様に公開元帳の役割を果たします。ただビットコインの場合とは異なり、Ethereumのアカウントのブロックチェーンには、トランザクションだけでなくEthereumネットワークの全アカウントの最新の状態に関する情報も記録されます。

つまり、ブロックチェーンにはトランザクションとアカウントの状態が記録されていき、そのブロックチェーンに書き込まれた状態を「正」とするEtherumネットワーク内の合意が形成されていきます。

Ethereumネットワーク内の採掘者は、etherの報酬を目当てに、ブロックの採掘競争を続けます。Ethereumでは、新しいブロックが平均して12秒に1回採掘されるように動的にプルーフ・オブ・ワークの難易度を調整されるように設計されています。

Ethereum では、採掘が成功すると、
* 1採掘当たり固定で5 ether
* ブロックに含まれる全てのcontractのコードを実行した際に消費したgasに相当するether
* ブロックに含んだ1つのUncleブロック当たり1/32 ether

の報酬が採掘者に与えられます。
